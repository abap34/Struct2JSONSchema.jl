var documenterSearchIndex = {"docs":
[{"location":"guide/#User-Guide","page":"User Guide","title":"User Guide","text":"This guide covers customization options and advanced features of Struct2JSONSchema.jl.","category":"section"},{"location":"guide/#Customization","page":"User Guide","title":"Customization","text":"generate_schema recursively generates schemas while updating a SchemaContext. By using override!, users can hook into this process and customize the generated schema.\n\n# Customize the generation so that UUID is represented as a string with format: uuid\nusing UUIDs\nusing JSON\n\nstruct User\n    id::UUID\n    name::String\nend\n\nctx = SchemaContext()\noverride!(ctx) do ctx\n    if current_type(ctx) === UUID\n        return Dict(\"type\" => \"string\", \"format\" => \"uuid\")\n    end\n    return nothing\nend\n\nresult = generate_schema(User; ctx=ctx)\nprintln(JSON.json(result.doc, 4))\n\nSchemaContext provides the following accessor functions for customization:\n\ncurrent_type(ctx) — the type currently being generated\ncurrent_parent(ctx) — the parent struct, when generating a field\ncurrent_field(ctx) — the field name, when generating a field\n\noverride! accepts a hook function that takes a SchemaContext object and returns either a schema Dict, or nothing to indicate that default generation should continue.\n\nIn practice, most customizations follow common patterns. For this reason, several helper functions are provided. Following customization are can be achieved using override!, but are more conveniently done using helper functions.","category":"section"},{"location":"guide/#Whole-type-overrides:-[override_type!](@ref)","page":"User Guide","title":"Whole-type overrides: override_type!","text":"Using override_type!, a specific type can always be overridden for generation with the given ctx. The following code is equivalent to the previous example.\n\nusing UUIDs\n\nstruct User\n    id::UUID\n    name::String\nend\n\nctx = SchemaContext()\noverride_type!(ctx, UUID) do ctx\n    Dict(\"type\" => \"string\", \"format\" => \"uuid\")\nend\n\nresult = generate_schema(User; ctx=ctx)","category":"section"},{"location":"guide/#Field-specific-overrides:-[override_field!](@ref)","page":"User Guide","title":"Field-specific overrides: override_field!","text":"Using override_field!, an override can be applied only to a specific field of a specific struct.\n\nstruct User\n    id::Int\n    email::String\nend\n\nctx = SchemaContext()\noverride_field!(ctx, User, :email) do ctx\n    Dict(\"type\" => \"string\", \"format\" => \"email\")\nend\n\nresult = generate_schema(User; ctx=ctx)","category":"section"},{"location":"guide/#Abstract-types:-[override_abstract!](@ref)","page":"User Guide","title":"Abstract types: override_abstract!","text":"Using override_abstract!, an identifier-based schema can be generated for abstract types with concrete subtypes.\n\nabstract type Event end\n\nstruct Deployment <: Event\n    id::Int\n    started_at::DateTime\nend\n\nstruct Alert <: Event\n    id::Int\n    acknowledged::Bool\nend\n\nstruct EventEnvelope\n    event::Event\n    received_at::DateTime\nend\n\nIn this situation, an abstract type may appear as a field type. A commonly desired schema is one where the event field of EventEnvelope takes the following form.\n\nvalid:\n\n[\n    { \"kind\": \"deployment\", \"id\": 123, \"started_at\": \"2024-01-01T12:00:00Z\" },\n    { \"kind\": \"alert\", \"id\": 456, \"acknowledged\": false }\n]\n\ninvalid:\n\n[\n    { \"id\": 123, \"started_at\": \"2024-01-01T12:00:00Z\" },\n    { \"id\": 456, \"acknowledged\": false }\n]\n\noverride_abstract! automatically generates such identifier-based schemas.\n\nctx = SchemaContext()\n\noverride_abstract!(\n    ctx,\n    Event;\n    variants = [Deployment, Alert],\n    discr_key = \"kind\",\n    tag_value = Dict(\n        Deployment => \"deployment\",\n        Alert => \"alert\"\n    )\n)\n\nschema = generate_schema(EventEnvelope; ctx = ctx)\nprintln(JSON.json(schema.doc, 4))","category":"section"},{"location":"guide/#Optional-Fields","page":"User Guide","title":"Optional Fields","text":"By default, Struct2JSONSchema.jl treats all fields as required.\n\nHowever, many users want fields of the following types to be treated as optional:\n\nUnion{T, Nothing}\nUnion{T, Missing}\n\nFor this purpose, the following helper functions are provided:\n\noptional! — explicitly mark fields as optional regardless of their type\nauto_optional_nothing! — treat Union{T, Nothing} fields as optional\nauto_optional_missing! — treat Union{T, Missing} fields as optional\nauto_optional_null! — treat both Union{T, Nothing} and Union{T, Missing} fields as optional\n\nstruct User\n    id::Int\n    name::String\n    birthdate::Union{Date, Nothing}\n    nickname::String\nend\n\nctx = SchemaContext()\noptional!(ctx, User, :nickname)\nauto_optional_nothing!(ctx)\ngenerate_schema(User; ctx=ctx)\n\nWith this configuration, both birthdate and nickname are treated as optional.","category":"section"},{"location":"guide/#Understanding-Optional-vs-Nullable","page":"User Guide","title":"Understanding Optional vs Nullable","text":"There is an important distinction between optional fields and nullable fields:\n\nWithout auto_optional_nothing! (default behavior):\n\nstruct User\n    name::String\n    email::Union{String, Nothing}\nend\n\nresult = generate_schema(User)\n\nGenerated schema:\n\nemail is required (in required array)\nemail accepts both String and null (via anyOf)\n\nValid JSON:\n\n{\"name\": \"Alice\", \"email\": \"alice@example.com\"}\n{\"name\": \"Bob\", \"email\": null}\n\nInvalid JSON:\n\n{\"name\": \"Charlie\"}  // email is missing\n\nWith auto_optional_nothing!:\n\nctx = SchemaContext()\nauto_optional_nothing!(ctx)\nresult = generate_schema(User; ctx=ctx)\n\nGenerated schema:\n\nemail is not required (not in required array)\nemail accepts only String (no null, no anyOf)\n\nValid JSON:\n\n{\"name\": \"Alice\", \"email\": \"alice@example.com\"}\n{\"name\": \"Bob\"}  // email can be omitted\n\nInvalid JSON:\n\n{\"name\": \"Charlie\", \"email\": null}  // null is not allowed when field is present\n\nIn other words, when using auto_optional_nothing!, the Nothing in Union{T, Nothing} is treated as a marker for optionality in Julia, not as a nullable value in JSON.","category":"section"},{"location":"guide/#Skipping-Fields","page":"User Guide","title":"Skipping Fields","text":"Use skip! to exclude fields or only! to include only specified fields:\n\nstruct User\n    id::Int\n    name::String\n    _cache::Dict\nend\n\nctx = SchemaContext()\nskip!(ctx, User, :_cache)\n# or equivalently:\n# only!(ctx, User, :id, :name)\n\nresult = generate_schema(User; ctx=ctx)\n\nSkipped fields are excluded from both properties and required.","category":"section"},{"location":"guide/#Field-Descriptions","page":"User Guide","title":"Field Descriptions","text":"Struct2JSONSchema.jl can automatically extract field docstrings and add them as description properties in the JSON Schema.","category":"section"},{"location":"guide/#Automatic-Extraction-from-Docstrings","page":"User Guide","title":"Automatic Extraction from Docstrings","text":"By default, field docstrings are automatically extracted:\n\n\"\"\"\nUser information\n\"\"\"\nstruct User\n    \"\"\"User's unique identifier\"\"\"\n    id::Int\n\n    \"\"\"User's full name\"\"\"\n    name::String\n\n    email::String  # No docstring\nend\n\nresult = generate_schema(User)\n# id and name fields will have \"description\" in the schema\n\nThis feature is controlled by the auto_fielddoc parameter in SchemaContext (default: true).\n\nNote: Field docstrings can only be extracted if the struct itself also has a docstring. Without a docstring on the struct definition, field docstrings are not stored by Julia and cannot be automatically extracted.","category":"section"},{"location":"guide/#Manual-Registration","page":"User Guide","title":"Manual Registration","text":"You can manually register field descriptions using describe!:\n\nstruct Product\n    id::Int\n    name::String\n    price::Float64\nend\n\nctx = SchemaContext()\ndescribe!(ctx, Product, :price, \"Product price in USD\")\n\nresult = generate_schema(Product; ctx=ctx)","category":"section"},{"location":"guide/#Integration-with-Field-Overrides","page":"User Guide","title":"Integration with Field Overrides","text":"Field descriptions work together with field overrides:\n\nstruct Product\n    id::Int\n    price::Float64\nend\n\nctx = SchemaContext()\n\n# Override adds constraint\noverride_field!(ctx, Product, :price) do ctx\n    Dict(\"type\" => \"number\", \"minimum\" => 0)\nend\n\n# Description is added to the overridden schema\ndescribe!(ctx, Product, :price, \"Product price in USD\")\n\nresult = generate_schema(Product; ctx=ctx)\n# price field will be:\n# {\n#   \"type\": \"number\",\n#   \"minimum\": 0,\n#   \"description\": \"Product price in USD\"\n# }","category":"section"},{"location":"guide/#Default-Values","page":"User Guide","title":"Default Values","text":"Use defaultvalue! to register default values for struct fields from an instance:\n\nusing Dates\n\nstruct ServerConfig\n    host::String\n    port::Int\n    timeout::Float64\n    started_at::DateTime\nend\n\nctx = SchemaContext()\n\ndefault_config = ServerConfig(\n    \"localhost\",\n    8080,\n    30.0,\n    DateTime(2024, 1, 1)\n)\n\ndefaultvalue!(ctx, default_config)\n\nresult = generate_schema(ServerConfig; ctx=ctx)\n# Each field will have a \"default\" property:\n# - host: \"localhost\"\n# - port: 8080\n# - timeout: 30.0\n# - started_at: \"2024-01-01T00:00:00\"\n\nNested structs are processed recursively, registering defaults at the leaf level:\n\nstruct Address\n    street::String\n    city::String\nend\n\nstruct Profile\n    name::String\n    address::Address\nend\n\nctx = SchemaContext()\ndefault_profile = Profile(\"Alice\", Address(\"Main St\", \"Metropolis\"))\ndefaultvalue!(ctx, default_profile)\n\n# Profile.name has default: \"Alice\"\n# Profile.address does NOT have a default (it's a nested struct)\n# Address.street has default: \"Main St\"\n# Address.city has default: \"Metropolis\"\n\nThis ensures that default values are only set at the deepest level (leaf fields), which is the correct behavior according to JSON Schema semantics.","category":"section"},{"location":"guide/#Custom-Serializers","page":"User Guide","title":"Custom Serializers","text":"For custom types, register a serializer:\n\nstruct Color\n    r::UInt8\n    g::UInt8\n    b::UInt8\nend\n\nstruct Theme\n    primary::Color\n    secondary::Color\nend\n\nctx = SchemaContext()\n\n# Serialize Color as hex string\ndefaultvalue_type_serializer!(ctx, Color) do value, ctx\n    r = string(value.r, base=16, pad=2)\n    g = string(value.g, base=16, pad=2)\n    b = string(value.b, base=16, pad=2)\n    \"#$(r)$(g)$(b)\"\nend\n\n# Also customize the schema\noverride_type!(ctx, Color) do ctx\n    Dict(\"type\" => \"string\", \"pattern\" => \"^#[0-9a-f]{6}\\$\")\nend\n\ndefault_theme = Theme(\n    Color(0x00, 0x7b, 0xff),\n    Color(0x6c, 0x75, 0x7d)\n)\n\ndefaultvalue!(ctx, default_theme)\n# primary.default: \"#007bff\"\n# secondary.default: \"#6c757d\"","category":"section"},{"location":"guide/#Override-Priority-for-Default-Values","page":"User Guide","title":"Override Priority for Default Values","text":"When an override sets a \"default\" property, it takes precedence over defaultvalue!:\n\nstruct Config\n    formatter::String\nend\n\nctx = SchemaContext()\n\n# Override sets default\noverride_field!(ctx, Config, :formatter) do ctx\n    Dict(\n        \"type\" => \"string\",\n        \"enum\" => [\"JuliaFormatter\", \"Runic\"],\n        \"default\" => \"JuliaFormatter\"  # Override sets default\n    )\nend\n\n# This will be ignored because override already set default\ndefaultvalue!(ctx, Config(\"Runic\"))\n\nresult = generate_schema(Config; ctx=ctx)\n# formatter.default: \"JuliaFormatter\" (from override, not \"Runic\")","category":"section"},{"location":"guide/#Registration-Priorities","page":"User Guide","title":"Registration Priorities","text":"","category":"section"},{"location":"guide/#Priority-Summary","page":"User Guide","title":"Priority Summary","text":"When multiple features are used together, the following priorities apply:\n\nFeature Priority\nSchema structure Override > Default generation\n\"default\" property Override > defaultvalue!\n\"description\" property Override > describe! > Auto-extraction\nrequired array Independent: optional! > Auto-detection","category":"section"},{"location":"guide/#Field-Description-Priority","page":"User Guide","title":"Field Description Priority","text":"Manual registration takes priority over automatic extraction:\n\nManual registration via describe! (highest priority)\nAutomatic extraction from field docstrings (if auto_fielddoc=true)\nNone (no description added)\n\nExample:\n\n\"\"\"\nEvent data\n\"\"\"\nstruct Event\n    \"\"\"Event ID from docstring\"\"\"\n    id::Int\nend\n\nctx = SchemaContext()\ndescribe!(ctx, Event, :id, \"Event unique ID (overridden)\")\n\nresult = generate_schema(Event; ctx=ctx)\n# id will have \"Event unique ID (overridden)\" as description","category":"section"},{"location":"guide/#Override-Evaluation-Order","page":"User Guide","title":"Override Evaluation Order","text":"All register_*_override! functions internally call override!, adding functions to ctx.overrides in FIFO (first-in, first-out) order.\n\nctx = SchemaContext()\n\noverride_type!(ctx, TypeA, gen1)      # 1st\noverride_field!(ctx, TypeB, :f, gen2) # 2nd\noverride_abstract!(ctx, AbstractType, ...)     # 3rd\n\nWhen generating a schema:\n\nThe first registered function is evaluated\nIf it returns a Dict: use that result (stop evaluation)\nIf it returns nothing: continue to next\nThe second function is evaluated, and so on\nFirst match wins","category":"section"},{"location":"guide/#How-Different-Systems-Interact","page":"User Guide","title":"How Different Systems Interact","text":"The following are separate systems that can be used together:\n\nctx.overrides — override mechanism\noptional_fields(ctx) — optional field management\nfield_descriptions(ctx) — field description management\ndefault_values(ctx) — default value management\n\nDuring field generation, they are processed in the following order:\n\nOverride evaluation → determines the field schema structure\nDefault value addition → adds \"default\" property if available and not set by override\nDescription addition → adds \"description\" property if available and not set by override\nOptional fields check → determines if the field goes in required array (independent system)","category":"section"},{"location":"guide/#Example:-All-Features-Combined","page":"User Guide","title":"Example: All Features Combined","text":"struct User\n    id::Int\n    email::String\nend\n\nctx = SchemaContext()\n\n# All four systems work together:\noverride_field!(ctx, User, :email) do ctx\n    Dict(\"type\" => \"string\", \"format\" => \"email\")\nend\n\ndefaultvalue!(ctx, User(1, \"user@example.com\"))\n\noptional!(ctx, User, :email)\n\ndescribe!(ctx, User, :email, \"User's email address\")\n\nresult = generate_schema(User; ctx=ctx)\n# email field will be:\n# {\n#   \"type\": \"string\",\n#   \"format\": \"email\",           // from override\n#   \"default\": \"user@example.com\", // from defaultvalue!\n#   \"description\": \"User's email address\" // from describe!\n# }\n# - not in required array (from optional_fields)","category":"section"},{"location":"guide/#Inline-Expansion-Mode","page":"User Guide","title":"Inline Expansion Mode","text":"For use cases where you need a completely flat schema without any $defs section (e.g., Visual Studio Code's JSON Schema support), Struct2JSONSchema.jl provides an inline_all_defs option:\n\nstruct Address\n    street::String\n    city::String\nend\n\nstruct Person\n    name::String\n    address::Address\nend\n\n# Standard mode: uses $defs with references\ndoc, _ = generate_schema(Person)\n# {\n#   \"$schema\": \"...\",\n#   \"$ref\": \"#/$defs/Person__...\",\n#   \"$defs\": {\n#     \"Person__...\": {...},\n#     \"Address__...\": {...}\n#   }\n# }\n\n# Inline expansion mode: everything is inlined\ndoc, _ = generate_schema(Person; inline_all_defs=true)\n# {\n#   \"$schema\": \"...\",\n#   \"type\": \"object\",\n#   \"properties\": {\n#     \"name\": {\"type\": \"string\"},\n#     \"address\": {\n#       \"type\": \"object\",\n#       \"properties\": {\n#         \"street\": {\"type\": \"string\"},\n#         \"city\": {\"type\": \"string\"}\n#       }\n#     }\n#   }\n# }\n\nwarning: Recursive Types and Inline Expansion\nRecursive definitions remain in $defs to avoid infinite expansion.struct Node\n    value::Int\n    next::Union{Node, Nothing}\nend\n\n# Recursive types must remain in $defs\ndoc, _ = generate_schema(Node; inline_all_defs=true)\n# {\n#   \"$ref\": \"#/$defs/Node__...\",\n#   \"$defs\": {\n#     \"Node__...\": {  # Cannot be inlined due to recursion\n#       \"anyOf\": [\n#         {\"$ref\": \"#/$defs/Node__...\"},\n#         {\"type\": \"null\"}\n#       ]\n#     }\n#   }\n# }","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Functions","page":"API Reference","title":"Core Functions","text":"","category":"section"},{"location":"api/#Context-Management","page":"API Reference","title":"Context Management","text":"","category":"section"},{"location":"api/#Type-Registration","page":"API Reference","title":"Type Registration","text":"","category":"section"},{"location":"api/#Optional-Fields","page":"API Reference","title":"Optional Fields","text":"","category":"section"},{"location":"api/#Field-Filtering","page":"API Reference","title":"Field Filtering","text":"","category":"section"},{"location":"api/#Default-Values","page":"API Reference","title":"Default Values","text":"","category":"section"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/#Struct2JSONSchema.generate_schema","page":"API Reference","title":"Struct2JSONSchema.generate_schema","text":"generate_schema(T; ctx=SchemaContext(), simplify=true, inline_all_defs=false)\n\nVariant of generate_schema! that clones the provided context before generation. The original ctx is unaffected.\n\nIf simplify=true (default), the schema is simplified by removing unused definitions, inlining single-use references, and sorting definitions.\n\nIf inline_all_defs=true, all $ref references are expanded inline and the $defs section is removed entirely (except for recursive definitions which must remain in $defs). This option takes precedence over simplify.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.generate_schema!","page":"API Reference","title":"Struct2JSONSchema.generate_schema!","text":"generate_schema!(T; ctx=SchemaContext(), simplify=true, inline_all_defs=false)\n\nMaterialize a schema for T using the provided mutable context. ctx is updated in-place and the function returns a named tuple with doc (the JSON schema document) and unknowns (newly encountered unsupported types).\n\nIf simplify=true (default), the schema is simplified by removing unused definitions, inlining single-use references, and sorting definitions.\n\nIf inline_all_defs=true, all $ref references are expanded inline and the $defs section is removed entirely (except for recursive definitions which must remain in $defs). This option takes precedence over simplify.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.SchemaContext","page":"API Reference","title":"Struct2JSONSchema.SchemaContext","text":"SchemaContext\n\nHolds all state required while generating JSON Schemas. The context tracks $defs, previously computed keys, the current traversal path, override registrations, and knobs for auto-detecting optional fields. Construct a context with SchemaContext() and pass it to the API helpers.\n\n\n\n\n\n","category":"type"},{"location":"api/#Struct2JSONSchema.UnknownEntry","page":"API Reference","title":"Struct2JSONSchema.UnknownEntry","text":"UnknownEntry\n\nRepresents a type that could not be processed, with a reason.\n\nFields\n\ntype::Any: The type that could not be processed\npath::Tuple{Vararg{Symbol}}: The path where the type was encountered\nreason::String: The reason why processing failed\n\n\n\n\n\n","category":"type"},{"location":"api/#Struct2JSONSchema.override_abstract!","page":"API Reference","title":"Struct2JSONSchema.override_abstract!","text":"override_abstract!(ctx, A; variants, discr_key, tag_value, require_discr=true)\n\nRegister a discriminator schema for the abstract type A. variants must be a vector of concrete subtypes, discr_key the discriminator field name, and tag_value a Dict mapping each variant to a JSON scalar tag. When require_discr is true the discriminator field is marked as required.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.override!","page":"API Reference","title":"Struct2JSONSchema.override!","text":"override!(generator, ctx)\n\nAppend a generic override function. generator receives the live SchemaContext and must return a replacement schema Dict or nothing to allow later overrides/default generation to run. Exceptions are caught; when ctx.verbose is true a warning is logged before falling back to the next candidate.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.override_type!","page":"API Reference","title":"Struct2JSONSchema.override_type!","text":"override_type!(generator, ctx, T)\n\nConvenience wrapper over override! that only fires when the currently generated type is exactly T. The supplied generator should return the full replacement schema for that type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.override_field!","page":"API Reference","title":"Struct2JSONSchema.override_field!","text":"override_field!(generator, ctx, T, field)\n\nRegister a context-aware override for the field field on struct T. The override runs while the field is visited and may return any schema Dict. Returning nothing falls back to downstream overrides or the default $ref.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.optional!","page":"API Reference","title":"Struct2JSONSchema.optional!","text":"optional!(ctx, T, fields...)\n\nMark specific fields on T as optional regardless of their declared types. fields may be supplied as a collection of Symbols or as varargs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.describe!","page":"API Reference","title":"Struct2JSONSchema.describe!","text":"describe!(ctx, T, field, description)\n\nRegister a description for the field field on struct T. The description will be added to the JSON Schema as the description property. Manual registration takes priority over automatic extraction via REPL.fielddoc.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.auto_optional_nothing!","page":"API Reference","title":"Struct2JSONSchema.auto_optional_nothing!","text":"Enable automatic Union{T,Nothing} → optional field detection.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.auto_optional_missing!","page":"API Reference","title":"Struct2JSONSchema.auto_optional_missing!","text":"Enable automatic Union{T,Missing} → optional field detection.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.auto_optional_null!","page":"API Reference","title":"Struct2JSONSchema.auto_optional_null!","text":"auto_optional_null!(ctx)\n\nHelper that enables both Union{T,Nothing} and Union{T,Missing} detection in one call.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.skip!","page":"API Reference","title":"Struct2JSONSchema.skip!","text":"skip!(ctx, T, fields...)\n\nMark specific fields on T to be completely skipped (excluded from schema generation). Skipped fields will not appear in properties or required. fields may be supplied as a collection of Symbols or as varargs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.only!","page":"API Reference","title":"Struct2JSONSchema.only!","text":"only!(ctx, T, fields...)\n\nMark that only the specified fields on T should be included in the schema. All other fields will be skipped. This is the inverse of skip!. fields may be supplied as a collection of Symbols or as varargs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.defaultvalue!","page":"API Reference","title":"Struct2JSONSchema.defaultvalue!","text":"defaultvalue!(ctx::SchemaContext, instance) -> Nothing\n\nRegister default values for all fields of a struct instance (recursively).\n\nExample\n\nctx = SchemaContext()\ndefaultvalue!(ctx, ServerConfig(\"localhost\", 8080))\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.defaultvalue_serializer!","page":"API Reference","title":"Struct2JSONSchema.defaultvalue_serializer!","text":"defaultvalue_serializer!(ctx::SchemaContext, serializer::Function) -> Nothing\n\nRegister a custom serializer for default values.\n\nSerializers are evaluated in FIFO order. Return nothing to fall through.\n\nExample\n\ndefaultvalue_serializer!(ctx) do field_type, value, ctx\n    value isa MyType ? serialize_my_type(value) : nothing\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.defaultvalue_type_serializer!","page":"API Reference","title":"Struct2JSONSchema.defaultvalue_type_serializer!","text":"defaultvalue_type_serializer!(ctx::SchemaContext, T::Type, serializer::Function) -> Nothing\n\nRegister a custom serializer for all values of type T.\n\nExample\n\ndefaultvalue_type_serializer!(ctx, Color) do value, ctx\n    \"#\" * join(string.(value.r, value.g, value.b), base=16, pad=2)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.defaultvalue_field_serializer!","page":"API Reference","title":"Struct2JSONSchema.defaultvalue_field_serializer!","text":"defaultvalue_field_serializer!(ctx::SchemaContext, Parent::Type, field::Symbol, serializer::Function) -> Nothing\n\nRegister a custom serializer for a specific field.\n\nExample\n\ndefaultvalue_field_serializer!(ctx, Metrics, :created_at) do value, ctx\n    Int(datetime2unix(value))\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Default-Type-Mappings","page":"Reference","title":"Default Type Mappings","text":"Currently, the following types are mapped to JSON Schema.\n\nJulia Type JSON Schema Type\nUnion{} {\"not\": {}}\nTuple{} {\"type\": \"array\", \"maxItems\": 0 }\nBool {\"type\": \"boolean\"}\nSubtypes of Integer except BigInt {\"type\": \"integer\", \"minimum\": typemin(T), \"maximum\": typemax(T)}\nBigInt, Integer {\"type\": \"integer\"}\nSubtypes of AbstractFloat {\"type\": \"number\" }\nSubtypes of Rational {\"type\": \"number\" }\nSubtypes of Irrational {\"type\": \"number\" }\nSubtypes of AbstractString {\"type\": \"string\" }\nChar {\"type\": \"string\", \"minLength\": 1, \"maxLength\": 1 }\nSymbol {\"type\": \"string\" }\nDate {\"type\": \"string\", \"format\": \"date\" }\nDateTime {\"type\": \"string\", \"format\": \"date-time\" }\nTime {\"type\": \"string\", \"format\": \"time\" }\nRegex {\"type\": \"string\", \"format\": \"regex\" }\nVersionNumber {\"type\": \"string\", \"pattern\": \"^\\\\d+\\\\.\\\\d+\\\\.\\\\d+.*$\" }\nNothing {\"type\": \"null\" }\nMissing {\"type\": \"null\" }\nAny {}","category":"section"},{"location":"reference/#Collection-Type-Mappings","page":"Reference","title":"Collection Type Mappings","text":"Here, schema(T) denotes the schema generated for type T (which becomes a $ref).\n\nJulia Type JSON Schema Type\nSubtypes of AbstractArray {\"type\": \"array\", \"items\": schema(eltype(T)) }\nSubtypes of AbstractSet {\"type\": \"array\", \"items\": schema(eltype(T)), \"uniqueItems\": true }\nTuple{T1, T2, …, TN} (no Vararg) {\"type\": \"array\", \"prefixItems\": [schema(T1), …, schema(TN)], \"minItems\": N, \"maxItems\": N }\nNTuple{N, T} {\"type\": \"array\", \"items\": schema(T), \"minItems\": N, \"maxItems\": N }\nTuple{Vararg{T}} or Tuple{Vararg{T, N}} {\"type\": \"array\", \"items\": schema(T) }\nNamedTuple{(:a, :b, …), Tuple{TA, TB, …}} {\"type\": \"object\", \"properties\": {\"a\": schema(TA), …}, \"required\": [\"a\", …], \"additionalProperties\": false }\nSubtypes of AbstractDict{K, V} {\"type\": \"object\", \"additionalProperties\": schema(V) }","category":"section"},{"location":"reference/#Examples","page":"Reference","title":"Examples","text":"For more detailed examples, see the examples directory.","category":"section"},{"location":"reference/#API-Reference","page":"Reference","title":"API Reference","text":"See the API Reference for detailed documentation of all exported functions.","category":"section"},{"location":"#Struct2JSONSchema.jl","page":"Home","title":"Struct2JSONSchema.jl","text":"Struct2JSONSchema.jl is a Julia package that converts Julia structs into JSON Schema documents compliant with draft 2020-12.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using Struct2JSONSchema\nusing JSON\n\nstruct User\n    id::Int\n    name::String\n    email::Union{String, Nothing}\nend\n\ndoc, unknowns = generate_schema(User)\nJSON.json(doc, 4)","category":"section"},{"location":"#Concepts","page":"Home","title":"Concepts","text":"","category":"section"},{"location":"#Non-invasive","page":"Home","title":"Non-invasive","text":"In many cases, struct definitions already exist and JSON Schema is needed afterward. In such situations, modifying existing struct definitions solely to generate JSON Schema is undesirable. Struct2JSONSchema.jl generates JSON Schema without making any changes to existing struct definitions.","category":"section"},{"location":"#Extensibility","page":"Home","title":"Extensibility","text":"Struct2JSONSchema.jl is designed to be customizable, allowing users to represent user-defined types and constraints.","category":"section"},{"location":"#Robustness","page":"Home","title":"Robustness","text":"Struct2JSONSchema.jl generates JSON Schema for all types. If a type cannot be represented, it falls back to Any, but it never raises an error.","category":"section"},{"location":"#Long-term-maintainability","page":"Home","title":"Long-term maintainability","text":"The implementation is simple, does not rely on Julia internal APIs, and has minimal dependencies. See Project.toml.","category":"section"},{"location":"#Non-goals","page":"Home","title":"Non-goals","text":"For these reasons, the following are explicitly not goals:\n\nAutomatically reflecting detailed semantics available on the Julia side into JSON Schema.\nSuch implementations tend to require significant effort for limited benefit and are fragile against future changes in Julia. Therefore, if such behavior is desired, users are expected to implement it manually via customization. Sufficient extensibility is provided for this purpose.\nAdvanced performance optimization.\nPrograms that take type definitions as input can often be highly optimized. However, schema generation is typically performed only once, with small inputs, and is unlikely to be a performance bottleneck. Simplicity of implementation is therefore prioritized.","category":"section"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"generate_schema takes a Julia type and returns a named tuple containing the schema document and a set of types that could not be represented.\n\nusing Struct2JSONSchema\n\nstruct Person\n    name::String\n    age::Int\nend\n\nresult = generate_schema(Person)\nprintln(result.doc)        # The document representing the JSON Schema\nprintln(result.unknowns)   # The set of unrepresentable types (empty in this case)\n\nIf a type cannot be represented in JSON Schema, it is recorded in unknowns:\n\nstruct CInterface\n    name::String\n    ptr::Ptr{Cvoid}  # Ptr cannot be represented in JSON Schema\nend\n\nresult = generate_schema(CInterface)\nprintln(result.unknowns)  # Set{Tuple{DataType, Tuple{Vararg{Symbol}}}}((Ptr{Nothing}, (:ptr,)))","category":"section"},{"location":"#Next-Steps","page":"Home","title":"Next Steps","text":"User Guide — Customization, optional fields, field descriptions, default values\nReference — Type mappings and API reference","category":"section"}]
}
