var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Functions","page":"API Reference","title":"Core Functions","text":"","category":"section"},{"location":"api/#Context-Management","page":"API Reference","title":"Context Management","text":"","category":"section"},{"location":"api/#Type-Registration","page":"API Reference","title":"Type Registration","text":"","category":"section"},{"location":"api/#Optional-Fields","page":"API Reference","title":"Optional Fields","text":"","category":"section"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/#Struct2JSONSchema.generate_schema","page":"API Reference","title":"Struct2JSONSchema.generate_schema","text":"generate_schema(T; ctx=SchemaContext())\n\nVariant of generate_schema! that clones the provided context before generation. The original ctx is unaffected.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.generate_schema!","page":"API Reference","title":"Struct2JSONSchema.generate_schema!","text":"generate_schema!(T; ctx=SchemaContext())\n\nMaterialize a schema for T using the provided mutable context. ctx is updated in-place and the function returns a named tuple with doc (the JSON schema document) and unknowns (newly encountered unsupported types).\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.SchemaContext","page":"API Reference","title":"Struct2JSONSchema.SchemaContext","text":"SchemaContext\n\nHolds all state required while generating JSON Schemas. The context tracks $defs, previously computed keys, the current traversal path, override registrations, and knobs for auto-detecting optional fields. Construct a context with SchemaContext() and pass it to the API helpers.\n\n\n\n\n\n","category":"type"},{"location":"api/#Struct2JSONSchema.register_abstract!","page":"API Reference","title":"Struct2JSONSchema.register_abstract!","text":"register_abstract!(ctx, A; variants, discr_key, tag_value, require_discr=true)\n\nRegister a discriminator schema for the abstract type A. variants must be a vector of concrete subtypes, discr_key the discriminator field name, and tag_value a Dict mapping each variant to a JSON scalar tag. When require_discr is true the discriminator field is marked as required.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.register_override!","page":"API Reference","title":"Struct2JSONSchema.register_override!","text":"register_override!(ctx, generator)\n\nAppend a generic override function. generator receives the live SchemaContext and must return a replacement schema Dict or nothing to allow later overrides/default generation to run. Exceptions are caught; when ctx.verbose is true a warning is logged before falling back to the next candidate.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.register_type_override!","page":"API Reference","title":"Struct2JSONSchema.register_type_override!","text":"register_type_override!(ctx, T, generator)\n\nConvenience wrapper over register_override! that only fires when the currently generated type is exactly T. The supplied generator should return the full replacement schema for that type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.register_field_override!","page":"API Reference","title":"Struct2JSONSchema.register_field_override!","text":"register_field_override!(ctx, T, field, generator)\n\nRegister a context-aware override for the field field on struct T. The override runs while the field is visited and may return any schema Dict. Returning nothing falls back to downstream overrides or the default $ref.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.treat_union_nothing_as_optional!","page":"API Reference","title":"Struct2JSONSchema.treat_union_nothing_as_optional!","text":"Enable automatic Union{T,Nothing} → optional field detection.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.treat_union_missing_as_optional!","page":"API Reference","title":"Struct2JSONSchema.treat_union_missing_as_optional!","text":"Enable automatic Union{T,Missing} → optional field detection.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.treat_null_as_optional!","page":"API Reference","title":"Struct2JSONSchema.treat_null_as_optional!","text":"treat_null_as_optional!(ctx)\n\nHelper that enables both Union{T,Nothing} and Union{T,Missing} detection in one call.\n\n\n\n\n\n","category":"function"},{"location":"#Struct2JSONSchema.jl","page":"Home","title":"Struct2JSONSchema.jl","text":"Struct2JSONSchema.jl is a Julia package that converts Julia structs into JSON Schema documents compliant with draft 2020-12.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using Struct2JSONSchema\nusing JSON\n\nstruct User\n    id::Int\n    name::String\n    email::Union{String, Nothing}\nend\n\ndoc, unknowns = generate_schema(User)\nJSON.json(doc, 4)","category":"section"},{"location":"#Concepts","page":"Home","title":"Concepts","text":"","category":"section"},{"location":"#Non-invasive","page":"Home","title":"Non-invasive","text":"In many cases, struct definitions already exist and JSON Schema is needed afterward. In such situations, modifying existing struct definitions solely to generate JSON Schema is undesirable. Struct2JSONSchema.jl generates JSON Schema without making any changes to existing struct definitions.","category":"section"},{"location":"#Extensibility","page":"Home","title":"Extensibility","text":"Struct2JSONSchema.jl is designed to be customizable, allowing users to represent user-defined types and constraints.","category":"section"},{"location":"#Robustness","page":"Home","title":"Robustness","text":"Struct2JSONSchema.jl generates JSON Schema for all types. If a type cannot be represented, it falls back to Any, but it never raises an error.","category":"section"},{"location":"#Long-term-maintainability","page":"Home","title":"Long-term maintainability","text":"The implementation is simple, does not rely on Julia internal APIs, and has minimal dependencies. See Project.toml.\n\nFor these reasons, the following are explicitly not goals:\n\nAutomatically reflecting detailed semantics available on the Julia side into JSON Schema.\nSuch implementations tend to require significant effort for limited benefit and are fragile against future changes in Julia. Therefore, if such behavior is desired, users are expected to implement it manually via customization. Sufficient extensibility is provided for this purpose.\nAdvanced performance optimization.\nPrograms that take type definitions as input can often be highly optimized. However, schema generation is typically performed only once, with small inputs, and is unlikely to be a performance bottleneck. Simplicity of implementation is therefore prioritized.","category":"section"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"generate_schema takes a Julia type and returns a named tuple containing the schema document and a set of types that could not be represented.\n\nusing Struct2JSONSchema\n\nstruct Person\n    name::String\n    age::Int\nend\n\nresult = generate_schema(Person)\nprintln(result.doc)        # The document representing the JSON Schema\nprintln(result.unknowns)   # The set of unrepresentable types (empty in this case)\n\nIf a type cannot be represented in JSON Schema, it is recorded in unknowns:\n\nstruct CInterface\n    name::String\n    ptr::Ptr{Cvoid}  # Ptr cannot be represented in JSON Schema\nend\n\nresult = generate_schema(CInterface)\nprintln(result.unknowns)  # Set{Tuple{DataType, Tuple{Vararg{Symbol}}}}((Ptr{Nothing}, (:ptr,)))","category":"section"},{"location":"#Customization","page":"Home","title":"Customization","text":"generate_schema recursively generates schemas while updating a SchemaContext. By using register_override!, users can hook into this process and customize the generated schema.\n\n# Customize the generation so that UUID is represented as a string with format: uuid\nusing UUIDs\nusing JSON\n\nstruct User\n    id::UUID\n    name::String\nend\n\nctx = SchemaContext()\nregister_override!(ctx) do ctx\n    if ctx.current_type === UUID\n        return Dict(\"type\" => \"string\", \"format\" => \"uuid\")\n    end\n    return nothing\nend\n\nresult = generate_schema(User; ctx=ctx)\nprintln(JSON.json(result.doc, 4))\n\nSchemaContext has the following fields, which can be used for customization:\n\ncurrent_type — the type currently being generated\ncurrent_parent — the parent struct, when generating a field\ncurrent_field — the field name, when generating a field\npath — the hierarchical path in the schema\n\nregister_override! accepts a hook function that takes a SchemaContext object and returns either a schema Dict, or nothing to indicate that default generation should continue.\n\nIn practice, most customizations follow common patterns. For this reason, several helper functions are provided.","category":"section"},{"location":"#Whole-type-overrides:-[register_type_override!](@ref)","page":"Home","title":"Whole-type overrides: register_type_override!","text":"Using register_type_override!, a specific type can always be overridden for generation with the given ctx. The following code is equivalent to the previous example.\n\nusing UUIDs\n\nstruct User\n    id::UUID\n    name::String\nend\n\nctx = SchemaContext()\nregister_type_override!(ctx, UUID) do ctx\n    Dict(\"type\" => \"string\", \"format\" => \"uuid\")\nend\n\nresult = generate_schema(User; ctx=ctx)","category":"section"},{"location":"#Field-specific-overrides:-[register_field_override!](@ref)","page":"Home","title":"Field-specific overrides: register_field_override!","text":"Using register_field_override!, an override can be applied only to a specific field of a specific struct.\n\nstruct User\n    id::Int\n    email::String\nend\n\nctx = SchemaContext()\nregister_field_override!(ctx, User, :email) do ctx\n    Dict(\"type\" => \"string\", \"format\" => \"email\")\nend\n\nresult = generate_schema(User; ctx=ctx)","category":"section"},{"location":"#Abstract-types:-[register_abstract!](@ref)","page":"Home","title":"Abstract types: register_abstract!","text":"Using register_abstract!, an identifier-based schema can be generated for abstract types with concrete subtypes.\n\nabstract type Event end\n\nstruct Deployment <: Event\n    id::Int\n    started_at::DateTime\nend\n\nstruct Alert <: Event\n    id::Int\n    acknowledged::Bool\nend\n\nstruct EventEnvelope\n    event::Event\n    received_at::DateTime\nend\n\nIn this situation, an abstract type may appear as a field type. A commonly desired schema is one where the event field of EventEnvelope takes the following form.\n\nvalid:\n\n[\n    { \"kind\": \"deployment\", \"id\": 123, \"started_at\": \"2024-01-01T12:00:00Z\" },\n    { \"kind\": \"alert\", \"id\": 456, \"acknowledged\": false }\n]\n\ninvalid:\n\n[\n    { \"id\": 123, \"started_at\": \"2024-01-01T12:00:00Z\" },\n    { \"id\": 456, \"acknowledged\": false }\n]\n\nregister_abstract! automatically generates such identifier-based schemas.\n\nctx = SchemaContext()\n\nregister_abstract!(\n    ctx,\n    Event;\n    variants = [Deployment, Alert],\n    discr_key = \"kind\",\n    tag_value = Dict(\n        Deployment => \"deployment\",\n        Alert => \"alert\"\n    )\n)\n\nschema = generate_schema(EventEnvelope; ctx = ctx)\nprintln(JSON.json(schema.doc, 4))","category":"section"},{"location":"#Optional-Fields","page":"Home","title":"Optional Fields","text":"By default, Struct2JSONSchema.jl treats all fields as required.\n\nHowever, many users want fields of the following types to be treated as optional:\n\nUnion{T, Nothing}\nUnion{T, Missing}\n\nFor this purpose, the following helper functions are provided:\n\ntreat_union_nothing_as_optional! — treat Union{T, Nothing} fields as optional\ntreat_union_missing_as_optional! — treat Union{T, Missing} fields as optional\ntreat_null_as_optional! — treat both Union{T, Nothing} and Union{T, Missing} fields as optional\n\nstruct User\n    id::Int\n    name::String\n    birthdate::Union{Date, Nothing}\nend\n\nctx = SchemaContext()\ntreat_union_nothing_as_optional!(ctx)\ngenerate_schema(User; ctx=ctx)\n\nWith this configuration, the birthdate field is treated as optional.","category":"section"},{"location":"#Default-Type-Mappings","page":"Home","title":"Default Type Mappings","text":"Currently, the following types are mapped to JSON Schema.\n\nJulia Type JSON Schema Type\nUnion{} {\"not\": {}}\nTuple{} {\"type\": \"array\", \"maxItems\": 0 }\nBool {\"type\": \"boolean\"}\nSubtypes of Integer except BigInt {\"type\": \"integer\", \"minimum\": typemin(T), \"maximum\": typemax(T)}\nBigInt, Integer {\"type\": \"integer\"}\nSubtypes of AbstractFloat {\"type\": \"number\" }\nSubtypes of Rational {\"type\": \"number\" }\nSubtypes of Irrational {\"type\": \"number\" }\nSubtypes of AbstractString {\"type\": \"string\" }\nChar {\"type\": \"string\", \"minLength\": 1, \"maxLength\": 1 }\nSymbol {\"type\": \"string\" }\nDate {\"type\": \"string\", \"format\": \"date\" }\nDateTime {\"type\": \"string\", \"format\": \"date-time\" }\nTime {\"type\": \"string\", \"format\": \"time\" }\nRegex {\"type\": \"string\", \"format\": \"regex\" }\nVersionNumber {\"type\": \"string\", \"pattern\": \"^\\\\d+\\\\.\\\\d+\\\\.\\\\d+.*$\" }\nNothing {\"type\": \"null\" }\nMissing {\"type\": \"null\" }\nAny {}","category":"section"},{"location":"#Collection-Type-Mappings","page":"Home","title":"Collection Type Mappings","text":"Here, schema(T) denotes the schema generated for type T (which becomes a $ref).\n\nJulia Type JSON Schema Type\nSubtypes of AbstractArray {\"type\": \"array\", \"items\": schema(eltype(T)) }\nSubtypes of AbstractSet {\"type\": \"array\", \"items\": schema(eltype(T)), \"uniqueItems\": true }\nTuple{T1, T2, …, TN} (no Vararg) {\"type\": \"array\", \"prefixItems\": [schema(T1), …, schema(TN)], \"minItems\": N, \"maxItems\": N }\nNTuple{N, T} {\"type\": \"array\", \"items\": schema(T), \"minItems\": N, \"maxItems\": N }\nTuple{Vararg{T}} or Tuple{Vararg{T, N}} {\"type\": \"array\", \"items\": schema(T) }\nNamedTuple{(:a, :b, …), Tuple{TA, TB, …}} {\"type\": \"object\", \"properties\": {\"a\": schema(TA), …}, \"required\": [\"a\", …], \"additionalProperties\": false }\nSubtypes of AbstractDict{K, V} {\"type\": \"object\", \"additionalProperties\": schema(V) }","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"For more detailed examples, see the examples directory.","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"See the API Reference for detailed documentation of all exported functions.","category":"section"}]
}
