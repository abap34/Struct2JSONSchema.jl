var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Functions","page":"API Reference","title":"Core Functions","text":"","category":"section"},{"location":"api/#Context-Management","page":"API Reference","title":"Context Management","text":"","category":"section"},{"location":"api/#Type-Registration","page":"API Reference","title":"Type Registration","text":"","category":"section"},{"location":"api/#Optional-Fields","page":"API Reference","title":"Optional Fields","text":"","category":"section"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/#Struct2JSONSchema.generate_schema","page":"API Reference","title":"Struct2JSONSchema.generate_schema","text":"generate_schema(T; ctx=SchemaContext(), simplify=true)\n\nVariant of generate_schema! that clones the provided context before generation. The original ctx is unaffected.\n\nIf simplify=true (default), the schema is simplified by removing unused definitions, inlining single-use references, and sorting definitions.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.generate_schema!","page":"API Reference","title":"Struct2JSONSchema.generate_schema!","text":"generate_schema!(T; ctx=SchemaContext(), simplify=true)\n\nMaterialize a schema for T using the provided mutable context. ctx is updated in-place and the function returns a named tuple with doc (the JSON schema document) and unknowns (newly encountered unsupported types).\n\nIf simplify=true (default), the schema is simplified by removing unused definitions, inlining single-use references, and sorting definitions.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.SchemaContext","page":"API Reference","title":"Struct2JSONSchema.SchemaContext","text":"SchemaContext\n\nHolds all state required while generating JSON Schemas. The context tracks $defs, previously computed keys, the current traversal path, override registrations, and knobs for auto-detecting optional fields. Construct a context with SchemaContext() and pass it to the API helpers.\n\n\n\n\n\n","category":"type"},{"location":"api/#Struct2JSONSchema.register_abstract!","page":"API Reference","title":"Struct2JSONSchema.register_abstract!","text":"register_abstract!(ctx, A; variants, discr_key, tag_value, require_discr=true)\n\nRegister a discriminator schema for the abstract type A. variants must be a vector of concrete subtypes, discr_key the discriminator field name, and tag_value a Dict mapping each variant to a JSON scalar tag. When require_discr is true the discriminator field is marked as required.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.register_override!","page":"API Reference","title":"Struct2JSONSchema.register_override!","text":"register_override!(ctx, generator)\n\nAppend a generic override function. generator receives the live SchemaContext and must return a replacement schema Dict or nothing to allow later overrides/default generation to run. Exceptions are caught; when ctx.verbose is true a warning is logged before falling back to the next candidate.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.register_type_override!","page":"API Reference","title":"Struct2JSONSchema.register_type_override!","text":"register_type_override!(ctx, T, generator)\n\nConvenience wrapper over register_override! that only fires when the currently generated type is exactly T. The supplied generator should return the full replacement schema for that type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.register_field_override!","page":"API Reference","title":"Struct2JSONSchema.register_field_override!","text":"register_field_override!(ctx, T, field, generator)\n\nRegister a context-aware override for the field field on struct T. The override runs while the field is visited and may return any schema Dict. Returning nothing falls back to downstream overrides or the default $ref.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.register_optional_fields!","page":"API Reference","title":"Struct2JSONSchema.register_optional_fields!","text":"register_optional_fields!(ctx, T, fields)\n\nMark specific fields on T as optional regardless of their declared types. fields may be supplied as a collection of Symbols or as varargs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.register_field_description!","page":"API Reference","title":"Struct2JSONSchema.register_field_description!","text":"register_field_description!(ctx, T, field, description)\n\nRegister a description for the field field on struct T. The description will be added to the JSON Schema as the description property. Manual registration takes priority over automatic extraction via REPL.fielddoc.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.treat_union_nothing_as_optional!","page":"API Reference","title":"Struct2JSONSchema.treat_union_nothing_as_optional!","text":"Enable automatic Union{T,Nothing} → optional field detection.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.treat_union_missing_as_optional!","page":"API Reference","title":"Struct2JSONSchema.treat_union_missing_as_optional!","text":"Enable automatic Union{T,Missing} → optional field detection.\n\n\n\n\n\n","category":"function"},{"location":"api/#Struct2JSONSchema.treat_null_as_optional!","page":"API Reference","title":"Struct2JSONSchema.treat_null_as_optional!","text":"treat_null_as_optional!(ctx)\n\nHelper that enables both Union{T,Nothing} and Union{T,Missing} detection in one call.\n\n\n\n\n\n","category":"function"},{"location":"#Struct2JSONSchema.jl","page":"Home","title":"Struct2JSONSchema.jl","text":"Struct2JSONSchema.jl is a Julia package that converts Julia structs into JSON Schema documents compliant with draft 2020-12.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using Struct2JSONSchema\nusing JSON\n\nstruct User\n    id::Int\n    name::String\n    email::Union{String, Nothing}\nend\n\ndoc, unknowns = generate_schema(User)\nJSON.json(doc, 4)","category":"section"},{"location":"#Concepts","page":"Home","title":"Concepts","text":"","category":"section"},{"location":"#Non-invasive","page":"Home","title":"Non-invasive","text":"In many cases, struct definitions already exist and JSON Schema is needed afterward. In such situations, modifying existing struct definitions solely to generate JSON Schema is undesirable. Struct2JSONSchema.jl generates JSON Schema without making any changes to existing struct definitions.","category":"section"},{"location":"#Extensibility","page":"Home","title":"Extensibility","text":"Struct2JSONSchema.jl is designed to be customizable, allowing users to represent user-defined types and constraints.","category":"section"},{"location":"#Robustness","page":"Home","title":"Robustness","text":"Struct2JSONSchema.jl generates JSON Schema for all types. If a type cannot be represented, it falls back to Any, but it never raises an error.","category":"section"},{"location":"#Long-term-maintainability","page":"Home","title":"Long-term maintainability","text":"The implementation is simple, does not rely on Julia internal APIs, and has minimal dependencies. See Project.toml.\n\nFor these reasons, the following are explicitly not goals:\n\nAutomatically reflecting detailed semantics available on the Julia side into JSON Schema.\nSuch implementations tend to require significant effort for limited benefit and are fragile against future changes in Julia. Therefore, if such behavior is desired, users are expected to implement it manually via customization. Sufficient extensibility is provided for this purpose.\nAdvanced performance optimization.\nPrograms that take type definitions as input can often be highly optimized. However, schema generation is typically performed only once, with small inputs, and is unlikely to be a performance bottleneck. Simplicity of implementation is therefore prioritized.","category":"section"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"generate_schema takes a Julia type and returns a named tuple containing the schema document and a set of types that could not be represented.\n\nusing Struct2JSONSchema\n\nstruct Person\n    name::String\n    age::Int\nend\n\nresult = generate_schema(Person)\nprintln(result.doc)        # The document representing the JSON Schema\nprintln(result.unknowns)   # The set of unrepresentable types (empty in this case)\n\nIf a type cannot be represented in JSON Schema, it is recorded in unknowns:\n\nstruct CInterface\n    name::String\n    ptr::Ptr{Cvoid}  # Ptr cannot be represented in JSON Schema\nend\n\nresult = generate_schema(CInterface)\nprintln(result.unknowns)  # Set{Tuple{DataType, Tuple{Vararg{Symbol}}}}((Ptr{Nothing}, (:ptr,)))","category":"section"},{"location":"#Customization","page":"Home","title":"Customization","text":"generate_schema recursively generates schemas while updating a SchemaContext. By using register_override!, users can hook into this process and customize the generated schema.\n\n# Customize the generation so that UUID is represented as a string with format: uuid\nusing UUIDs\nusing JSON\n\nstruct User\n    id::UUID\n    name::String\nend\n\nctx = SchemaContext()\nregister_override!(ctx) do ctx\n    if ctx.current_type === UUID\n        return Dict(\"type\" => \"string\", \"format\" => \"uuid\")\n    end\n    return nothing\nend\n\nresult = generate_schema(User; ctx=ctx)\nprintln(JSON.json(result.doc, 4))\n\nSchemaContext has the following fields, which can be used for customization:\n\ncurrent_type — the type currently being generated\ncurrent_parent — the parent struct, when generating a field\ncurrent_field — the field name, when generating a field\npath — the hierarchical path in the schema\n\nregister_override! accepts a hook function that takes a SchemaContext object and returns either a schema Dict, or nothing to indicate that default generation should continue.\n\nIn practice, most customizations follow common patterns. For this reason, several helper functions are provided.","category":"section"},{"location":"#Whole-type-overrides:-[register_type_override!](@ref)","page":"Home","title":"Whole-type overrides: register_type_override!","text":"Using register_type_override!, a specific type can always be overridden for generation with the given ctx. The following code is equivalent to the previous example.\n\nusing UUIDs\n\nstruct User\n    id::UUID\n    name::String\nend\n\nctx = SchemaContext()\nregister_type_override!(ctx, UUID) do ctx\n    Dict(\"type\" => \"string\", \"format\" => \"uuid\")\nend\n\nresult = generate_schema(User; ctx=ctx)","category":"section"},{"location":"#Field-specific-overrides:-[register_field_override!](@ref)","page":"Home","title":"Field-specific overrides: register_field_override!","text":"Using register_field_override!, an override can be applied only to a specific field of a specific struct.\n\nstruct User\n    id::Int\n    email::String\nend\n\nctx = SchemaContext()\nregister_field_override!(ctx, User, :email) do ctx\n    Dict(\"type\" => \"string\", \"format\" => \"email\")\nend\n\nresult = generate_schema(User; ctx=ctx)","category":"section"},{"location":"#Abstract-types:-[register_abstract!](@ref)","page":"Home","title":"Abstract types: register_abstract!","text":"Using register_abstract!, an identifier-based schema can be generated for abstract types with concrete subtypes.\n\nabstract type Event end\n\nstruct Deployment <: Event\n    id::Int\n    started_at::DateTime\nend\n\nstruct Alert <: Event\n    id::Int\n    acknowledged::Bool\nend\n\nstruct EventEnvelope\n    event::Event\n    received_at::DateTime\nend\n\nIn this situation, an abstract type may appear as a field type. A commonly desired schema is one where the event field of EventEnvelope takes the following form.\n\nvalid:\n\n[\n    { \"kind\": \"deployment\", \"id\": 123, \"started_at\": \"2024-01-01T12:00:00Z\" },\n    { \"kind\": \"alert\", \"id\": 456, \"acknowledged\": false }\n]\n\ninvalid:\n\n[\n    { \"id\": 123, \"started_at\": \"2024-01-01T12:00:00Z\" },\n    { \"id\": 456, \"acknowledged\": false }\n]\n\nregister_abstract! automatically generates such identifier-based schemas.\n\nctx = SchemaContext()\n\nregister_abstract!(\n    ctx,\n    Event;\n    variants = [Deployment, Alert],\n    discr_key = \"kind\",\n    tag_value = Dict(\n        Deployment => \"deployment\",\n        Alert => \"alert\"\n    )\n)\n\nschema = generate_schema(EventEnvelope; ctx = ctx)\nprintln(JSON.json(schema.doc, 4))","category":"section"},{"location":"#Optional-Fields","page":"Home","title":"Optional Fields","text":"By default, Struct2JSONSchema.jl treats all fields as required.\n\nHowever, many users want fields of the following types to be treated as optional:\n\nUnion{T, Nothing}\nUnion{T, Missing}\n\nFor this purpose, the following helper functions are provided:\n\nregister_optional_fields! — explicitly mark fields as optional regardless of their type\ntreat_union_nothing_as_optional! — treat Union{T, Nothing} fields as optional\ntreat_union_missing_as_optional! — treat Union{T, Missing} fields as optional\ntreat_null_as_optional! — treat both Union{T, Nothing} and Union{T, Missing} fields as optional\n\nstruct User\n    id::Int\n    name::String\n    birthdate::Union{Date, Nothing}\n    nickname::String\nend\n\nctx = SchemaContext()\nregister_optional_fields!(ctx, User, :nickname)\ntreat_union_nothing_as_optional!(ctx)\ngenerate_schema(User; ctx=ctx)\n\nWith this configuration, both birthdate and nickname are treated as optional.","category":"section"},{"location":"#Understanding-Optional-vs-Nullable","page":"Home","title":"Understanding Optional vs Nullable","text":"There is an important distinction between optional fields and nullable fields:\n\nWithout treat_union_nothing_as_optional! (default behavior):\n\nstruct User\n    name::String\n    email::Union{String, Nothing}\nend\n\nresult = generate_schema(User)\n\nGenerated schema:\n\nemail is required (in required array)\nemail accepts both String and null (via anyOf)\n\nValid JSON:\n\n{\"name\": \"Alice\", \"email\": \"alice@example.com\"}\n{\"name\": \"Bob\", \"email\": null}\n\nInvalid JSON:\n\n{\"name\": \"Charlie\"}  // email is missing\n\nWith treat_union_nothing_as_optional!:\n\nctx = SchemaContext()\ntreat_union_nothing_as_optional!(ctx)\nresult = generate_schema(User; ctx=ctx)\n\nGenerated schema:\n\nemail is not required (not in required array)\nemail accepts only String (no null, no anyOf)\n\nValid JSON:\n\n{\"name\": \"Alice\", \"email\": \"alice@example.com\"}\n{\"name\": \"Bob\"}  // email can be omitted\n\nInvalid JSON:\n\n{\"name\": \"Charlie\", \"email\": null}  // null is not allowed when field is present\n\nIn other words, when using treat_union_nothing_as_optional!, the Nothing in Union{T, Nothing} is treated as a marker for optionality in Julia, not as a nullable value in JSON.","category":"section"},{"location":"#Field-Descriptions","page":"Home","title":"Field Descriptions","text":"Struct2JSONSchema.jl can automatically extract field docstrings and add them as description properties in the JSON Schema.","category":"section"},{"location":"#Automatic-Extraction-from-Docstrings","page":"Home","title":"Automatic Extraction from Docstrings","text":"By default, field docstrings are automatically extracted:\n\n\"\"\"\nUser information\n\"\"\"\nstruct User\n    \"\"\"User's unique identifier\"\"\"\n    id::Int\n\n    \"\"\"User's full name\"\"\"\n    name::String\n\n    email::String  # No docstring\nend\n\nresult = generate_schema(User)\n# id and name fields will have \"description\" in the schema\n\nThis feature is controlled by the auto_fielddoc parameter in SchemaContext (default: true).\n\nNote: Field docstrings can only be extracted if the struct itself also has a docstring. Without a docstring on the struct definition, field docstrings are not stored by Julia and cannot be automatically extracted.","category":"section"},{"location":"#Manual-Registration","page":"Home","title":"Manual Registration","text":"You can manually register field descriptions using register_field_description!:\n\nstruct Product\n    id::Int\n    name::String\n    price::Float64\nend\n\nctx = SchemaContext()\nregister_field_description!(ctx, Product, :price, \"Product price in USD\")\n\nresult = generate_schema(Product; ctx=ctx)","category":"section"},{"location":"#Integration-with-Field-Overrides","page":"Home","title":"Integration with Field Overrides","text":"Field descriptions work together with field overrides:\n\nstruct Product\n    id::Int\n    price::Float64\nend\n\nctx = SchemaContext()\n\n# Override adds constraint\nregister_field_override!(ctx, Product, :price) do ctx\n    Dict(\"type\" => \"number\", \"minimum\" => 0)\nend\n\n# Description is added to the overridden schema\nregister_field_description!(ctx, Product, :price, \"Product price in USD\")\n\nresult = generate_schema(Product; ctx=ctx)\n# price field will be:\n# {\n#   \"type\": \"number\",\n#   \"minimum\": 0,\n#   \"description\": \"Product price in USD\"\n# }","category":"section"},{"location":"#Registration-Priorities","page":"Home","title":"Registration Priorities","text":"","category":"section"},{"location":"#Field-Description-Priority","page":"Home","title":"Field Description Priority","text":"Manual registration takes priority over automatic extraction:\n\nManual registration via register_field_description! (highest priority)\nAutomatic extraction from field docstrings (if auto_fielddoc=true)\nNone (no description added)\n\nExample:\n\n\"\"\"\nEvent data\n\"\"\"\nstruct Event\n    \"\"\"Event ID from docstring\"\"\"\n    id::Int\nend\n\nctx = SchemaContext()\nregister_field_description!(ctx, Event, :id, \"Event unique ID (overridden)\")\n\nresult = generate_schema(Event; ctx=ctx)\n# id will have \"Event unique ID (overridden)\" as description","category":"section"},{"location":"#Override-Evaluation-Order","page":"Home","title":"Override Evaluation Order","text":"All register_*_override! functions internally call register_override!, adding functions to ctx.overrides in FIFO (first-in, first-out) order.\n\nctx = SchemaContext()\n\nregister_type_override!(ctx, TypeA, gen1)      # 1st\nregister_field_override!(ctx, TypeB, :f, gen2) # 2nd\nregister_abstract!(ctx, AbstractType, ...)     # 3rd\n\nWhen generating a schema:\n\nThe first registered function is evaluated\nIf it returns a Dict: use that result (stop evaluation)\nIf it returns nothing: continue to next\nThe second function is evaluated, and so on\nFirst match wins","category":"section"},{"location":"#How-Different-Systems-Interact","page":"Home","title":"How Different Systems Interact","text":"The following are separate systems that can be used together:\n\nctx.overrides — override mechanism\nctx.optional_fields — optional field management\nctx.field_descriptions — field description management\n\nDuring field generation, they are processed in the following order:\n\nOverride evaluation → determines the field schema\nOptional fields check → determines if the field goes in required array\nDescription addition → adds description property if available","category":"section"},{"location":"#Example:-All-Features-Combined","page":"Home","title":"Example: All Features Combined","text":"struct User\n    id::Int\n    email::String\nend\n\nctx = SchemaContext()\n\n# All three systems work together:\nregister_field_override!(ctx, User, :email) do ctx\n    Dict(\"type\" => \"string\", \"format\" => \"email\")\nend\n\nregister_optional_fields!(ctx, User, :email)\n\nregister_field_description!(ctx, User, :email, \"User's email address\")\n\nresult = generate_schema(User; ctx=ctx)\n# email field will be:\n# - format: \"email\" (from override)\n# - not in required array (from optional_fields)\n# - description: \"User's email address\" (from field_descriptions)","category":"section"},{"location":"#Default-Type-Mappings","page":"Home","title":"Default Type Mappings","text":"Currently, the following types are mapped to JSON Schema.\n\nJulia Type JSON Schema Type\nUnion{} {\"not\": {}}\nTuple{} {\"type\": \"array\", \"maxItems\": 0 }\nBool {\"type\": \"boolean\"}\nSubtypes of Integer except BigInt {\"type\": \"integer\", \"minimum\": typemin(T), \"maximum\": typemax(T)}\nBigInt, Integer {\"type\": \"integer\"}\nSubtypes of AbstractFloat {\"type\": \"number\" }\nSubtypes of Rational {\"type\": \"number\" }\nSubtypes of Irrational {\"type\": \"number\" }\nSubtypes of AbstractString {\"type\": \"string\" }\nChar {\"type\": \"string\", \"minLength\": 1, \"maxLength\": 1 }\nSymbol {\"type\": \"string\" }\nDate {\"type\": \"string\", \"format\": \"date\" }\nDateTime {\"type\": \"string\", \"format\": \"date-time\" }\nTime {\"type\": \"string\", \"format\": \"time\" }\nRegex {\"type\": \"string\", \"format\": \"regex\" }\nVersionNumber {\"type\": \"string\", \"pattern\": \"^\\\\d+\\\\.\\\\d+\\\\.\\\\d+.*$\" }\nNothing {\"type\": \"null\" }\nMissing {\"type\": \"null\" }\nAny {}","category":"section"},{"location":"#Collection-Type-Mappings","page":"Home","title":"Collection Type Mappings","text":"Here, schema(T) denotes the schema generated for type T (which becomes a $ref).\n\nJulia Type JSON Schema Type\nSubtypes of AbstractArray {\"type\": \"array\", \"items\": schema(eltype(T)) }\nSubtypes of AbstractSet {\"type\": \"array\", \"items\": schema(eltype(T)), \"uniqueItems\": true }\nTuple{T1, T2, …, TN} (no Vararg) {\"type\": \"array\", \"prefixItems\": [schema(T1), …, schema(TN)], \"minItems\": N, \"maxItems\": N }\nNTuple{N, T} {\"type\": \"array\", \"items\": schema(T), \"minItems\": N, \"maxItems\": N }\nTuple{Vararg{T}} or Tuple{Vararg{T, N}} {\"type\": \"array\", \"items\": schema(T) }\nNamedTuple{(:a, :b, …), Tuple{TA, TB, …}} {\"type\": \"object\", \"properties\": {\"a\": schema(TA), …}, \"required\": [\"a\", …], \"additionalProperties\": false }\nSubtypes of AbstractDict{K, V} {\"type\": \"object\", \"additionalProperties\": schema(V) }","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"For more detailed examples, see the examples directory.","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"See the API Reference for detailed documentation of all exported functions.","category":"section"}]
}
